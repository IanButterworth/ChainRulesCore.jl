<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>FAQ · ChainRules</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><link href="assets/chainrules.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.svg" alt="ChainRules logo"/></a><h1>ChainRules</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li class="current"><a class="toctext" href="FAQ.html">FAQ</a><ul class="internal"><li><a class="toctext" href="#What-is-up-with-the-different-symbols?-1">What is up with the different symbols?</a></li><li><a class="toctext" href="#Why-does-rrule-return-the-primal-function-evaluation?-1">Why does <code>rrule</code> return the primal function evaluation?</a></li><li><a class="toctext" href="#Where-are-the-derivatives-for-keyword-arguments?-1">Where are the derivatives for keyword arguments?</a></li><li><a class="toctext" href="#What-is-the-difference-between-Zero-and-DoesNotExist-?-1">What is the difference between <code>Zero</code> and <code>DoesNotExist</code> ?</a></li><li><a class="toctext" href="#When-to-use-ChainRules-vs-ChainRulesCore?-1">When to use ChainRules vs ChainRulesCore?</a></li><li><a class="toctext" href="#Where-should-I-put-my-rules?-1">Where should I put my rules?</a></li><li><a class="toctext" href="#How-do-I-test-my-rules?-1">How do I test my rules?</a></li></ul></li><li><a class="toctext" href="writing_good_rules.html">Writing Good Rules</a></li><li><a class="toctext" href="debug_mode.html">Debug Mode</a></li><li><span class="toctext">Design</span><ul><li><a class="toctext" href="design/many_differentials.html">Many Differential Types</a></li><li><a class="toctext" href="design/zeros.html">Zeros and Not Defined</a></li></ul></li><li><a class="toctext" href="api.html">API</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="FAQ.html">FAQ</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/master/docs/src/FAQ.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>FAQ</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="FAQ-1" href="#FAQ-1">FAQ</a></h1><h2><a class="nav-anchor" id="What-is-up-with-the-different-symbols?-1" href="#What-is-up-with-the-different-symbols?-1">What is up with the different symbols?</a></h2><h3><a class="nav-anchor" id="Δx,-x,-dx-1" href="#Δx,-x,-dx-1"><code>Δx</code>, <code>∂x</code>, <code>dx</code></a></h3><p>ChainRules uses these perhaps atypically. As a notation that is the same across propagators, regardless of direction (incontrast see <code>ẋ</code> and <code>x̄</code> below).</p><ul><li><code>Δx</code> is the input to a propagator, (i.e a <em>seed</em> for a <em>pullback</em>; or a <em>perturbation</em> for a <em>pushforward</em>)</li><li><code>∂x</code> is the output of a propagator</li><li><code>dx</code> could be either <code>input</code> or <code>output</code></li></ul><h3><a class="nav-anchor" id="dots-and-bars:-\\dot{y}-\\dfrac{y}{x}-\\overline{x}-1" href="#dots-and-bars:-\\dot{y}-\\dfrac{y}{x}-\\overline{x}-1">dots and bars: <span>$\dot{y} = \dfrac{∂y}{∂x} = \overline{x}$</span></a></h3><ul><li><code>v̇</code> is a derivative of the input moving forward: <span>$v̇ = \frac{∂v}{∂x}$</span> for input <span>$x$</span>, intermediate value <span>$v$</span>.</li><li><code>v̄</code> is a derivative of the output moving backward: <span>$v̄ = \frac{∂y}{∂v}$</span> for output <span>$y$</span>, intermediate value <span>$v$</span>.</li></ul><h3><a class="nav-anchor" id="others-1" href="#others-1">others</a></h3><ul><li><code>Ω</code> is often used as the return value of the function. Especially, but not exclusively, for scalar functions.<ul><li><code>ΔΩ</code> is thus a seed for the pullback.</li><li><code>∂Ω</code> is thus the output of a pushforward.</li></ul></li></ul><h2><a class="nav-anchor" id="Why-does-rrule-return-the-primal-function-evaluation?-1" href="#Why-does-rrule-return-the-primal-function-evaluation?-1">Why does <code>rrule</code> return the primal function evaluation?</a></h2><p>You might wonder why <code>frule(f, x)</code> returns <code>f(x)</code> and the derivative of <code>f</code> at <code>x</code>, and similarly for <code>rrule</code> returning <code>f(x)</code> and the pullback for <code>f</code> at <code>x</code>. Why not just return the pushforward/pullback, and let the user call <code>f(x)</code> to get the answer separately?</p><p>There are three reasons the rules also calculate the <code>f(x)</code>.</p><ol><li>For some rules an alternative way of calculating <code>f(x)</code> can give the same answer while also generating intermediate values that can be used in the calculations required to propagate the derivative.</li><li>For many <code>rrule</code>s the output value is used in the definition of the pullback. For example <code>tan</code>, <code>sigmoid</code> etc.</li><li>For some <code>frule</code>s there exists a single, non-separable operation that will compute both derivative and primal result. For example many of the methods for <a href="https://docs.juliadiffeq.org/stable/analysis/sensitivity/#sensitivity-1">differential equation sensitivity analysis</a>.</li></ol><h2><a class="nav-anchor" id="Where-are-the-derivatives-for-keyword-arguments?-1" href="#Where-are-the-derivatives-for-keyword-arguments?-1">Where are the derivatives for keyword arguments?</a></h2><p><em>pullbacks</em> do not return a sensitivity for keyword arguments; similarly <em>pushfowards</em> do not accept a perturbation for keyword arguments. This is because in practice functions are very rarely differentiable with respect to keyword arguments. As a rule keyword arguments tend to control side-effects, like logging verbosity, or to be functionality changing to perform a different operation, e.g. <code>dims=3</code>, and thus not differentiable. To the best of our knowledge no Julia AD system, with support for the definition of custom primitives, supports differentiating with respect to keyword arguments. At some point in the future ChainRules may support these. Maybe.</p><h2><a class="nav-anchor" id="What-is-the-difference-between-Zero-and-DoesNotExist-?-1" href="#What-is-the-difference-between-Zero-and-DoesNotExist-?-1">What is the difference between <code>Zero</code> and <code>DoesNotExist</code> ?</a></h2><p><code>Zero</code> and <code>DoesNotExist</code> act almost exactly the same in practice: they result in no change whenever added to anything. Odds are if you write a rule that returns the wrong one everything will just work fine. We provide both to allow for clearer writing of rules, and easier debugging.</p><p><code>Zero()</code> represents the fact that if one perturbs (adds a small change to) the matching primal there will be no change in the behavour of the primal function. For example in <code>fst(x,y) = x</code>, then the derivative of <code>fst</code> with respect to <code>y</code> is <code>Zero()</code>. <code>fst(10, 5) == 10</code> and if we add <code>0.1</code> to <code>5</code> we still get <code>fst(10, 5.1)=10</code>.</p><p><code>DoesNotExist()</code> represents the fact that if one perturbs the matching primal, the primal function will now error. For example in <code>access(xs, n) = xs[n]</code> then the derivative of <code>access</code> with respect to <code>n</code> is <code>DoesNotExist()</code>. <code>access([10, 20, 30], 2) = 20</code>, but if we add <code>0.1</code> to <code>2</code> we get <code>access([10, 20, 30], 2.1)</code> which errors as indexing can&#39;t be applied at fractional indexes.</p><h2><a class="nav-anchor" id="When-to-use-ChainRules-vs-ChainRulesCore?-1" href="#When-to-use-ChainRules-vs-ChainRulesCore?-1">When to use ChainRules vs ChainRulesCore?</a></h2><p><a href="https://github.com/JuliaDiff/ChainRulesCore.jl">ChainRulesCore.jl</a> is a light-weight dependency for defining rules for functions in your packages, without you needing to depend on ChainRules.jl itself. It has almost no dependencies of its own. If you only want to define rules, not use them, then you probably only want to load ChainRulesCore.jl.</p><p><a href="https://github.com/JuliaDiff/ChainRules.jl">ChainRules.jl</a> provides the full functionality for AD systems, in particular it has all the rules for Base Julia and the standard libraries. It is thus a much heavier package to load. AD systems making use of <code>frule</code>s and <code>rrule</code>s should load ChainRules.jl.</p><h2><a class="nav-anchor" id="Where-should-I-put-my-rules?-1" href="#Where-should-I-put-my-rules?-1">Where should I put my rules?</a></h2><p>We recommend adding custom rules to your own packages with <a href="https://github.com/JuliaDiff/ChainRulesCore.jl">ChainRulesCore.jl</a>, rather than adding them to ChainRules.jl. A few packages - currently SpecialFunctions.jl and NaNMath.jl - have rules in ChainRules.jl as a short-term measure.</p><h2><a class="nav-anchor" id="How-do-I-test-my-rules?-1" href="#How-do-I-test-my-rules?-1">How do I test my rules?</a></h2><p>You can use <a href="https://github.com/JuliaDiff/ChainRulesTestUtils.jl">ChainRulesTestUtils.jl</a> to test your custom rules. ChainRulesTestUtils.jl has some dependencies, so it is a separate package from ChainRulesCore.jl. This means your package can depend on the light-weight ChainRulesCore.jl, and make ChainRulesTestUtils.jl a test-only dependency.</p><p>Remember to read the section on <a href="writing_good_rules.html#On-writing-good-rrule-/-frule-methods-1">On writing good <code>rrule</code> / <code>frule</code> methods</a>.</p><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="writing_good_rules.html"><span class="direction">Next</span><span class="title">Writing Good Rules</span></a></footer></article></body></html>
