<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Deriving Array Rules · ChainRules</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><link href="assets/chainrules.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.svg" alt="ChainRules logo"/></a><h1>ChainRules</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li><a class="toctext" href="FAQ.html">FAQ</a></li><li><a class="toctext" href="writing_good_rules.html">Writing Good Rules</a></li><li><a class="toctext" href="complex.html">Complex Numbers</a></li><li class="current"><a class="toctext" href="arrays.html">Deriving Array Rules</a><ul class="internal"><li><a class="toctext" href="#Forward-mode-rules-1">Forward-mode rules</a></li><li><a class="toctext" href="#Reverse-mode-rules-1">Reverse-mode rules</a></li><li><a class="toctext" href="#A-multidimensional-array-example-1">A multidimensional array example</a></li><li><a class="toctext" href="#More-examples-1">More examples</a></li><li><a class="toctext" href="#References-1">References</a></li></ul></li><li><a class="toctext" href="debug_mode.html">Debug Mode</a></li><li><span class="toctext">Design</span><ul><li><a class="toctext" href="design/many_differentials.html">Many Differential Types</a></li></ul></li><li><a class="toctext" href="api.html">API</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="arrays.html">Deriving Array Rules</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/master/docs/src/arrays.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Deriving Array Rules</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Deriving-Array-Rules-1" href="#Deriving-Array-Rules-1">Deriving Array Rules</a></h1><p>One of the goals of the ChainRules interface is to make it easy to define your own rules for a function. This tutorial attempts to demystify deriving and implementing custom rules for arrays with real and complex entries, with examples. The approach we use is similar to the one succinctly explained and demonstrated in <a href="#footnote-Giles2008">[Giles2008]</a> and its extended work <a href="#footnote-Giles2008ext">[Giles2008ext]</a>, but we generalize it to support functions of multidimensional arrays with both real and complex entries.</p><p>Throughout this tutorial, we will use the following type alias:</p><pre><code class="language-julia">const RealOrComplex = Union{Real,Complex}</code></pre><h2><a class="nav-anchor" id="Forward-mode-rules-1" href="#Forward-mode-rules-1">Forward-mode rules</a></h2><h3><a class="nav-anchor" id="Approach-1" href="#Approach-1">Approach</a></h3><p>Consider a function</p><pre><code class="language-julia">Ω = f(X::Array{&lt;:RealOrComplex}...)::Array{&lt;:RealOrComplex}</code></pre><p>or in math notation</p><div>\[f: (\ldots, X_m, \ldots) \mapsto \Omega,\]</div><p>where the components of <span>$X_m$</span> are written as <span>$(X_m)_{i,\ldots,j}$</span>. The variables <span>$X_m$</span> and <span>$\Omega$</span> are intermediates in a larger program (function) that, by considering only a single real input <span>$t$</span> and real output <span>$s$</span> can always be written as</p><div>\[t \mapsto (\ldots, X_m, \ldots) \mapsto \Omega \mapsto s,\]</div><p>where <span>$t$</span> and <span>$s$</span> are real numbers. If we know the partial derivatives of <span>$X_m$</span> with respect to <span>$t$</span>, <span>$\frac{dX_m}{dt} = \dot{X}_m$</span>, the chain rule gives the pushforward of <span>$f$</span> as:</p><div>\[\begin{equation} \label{pf}
\dot{\Omega}
    = f_*(\ldots, \dot{X}_m, \ldots)
    = \sum_m \sum_{i, \ldots, j}
        \frac{\partial \Omega}{ \partial (X_m)_{i,\ldots,j} } (\dot{X}_m)_{i,\ldots,j}
\end{equation}\]</div><p>That&#39;s ugly, but in practice we can often write it more simply by using forward mode rules for simpler functions, as we&#39;ll see below. The forward-mode rules for arrays follow directly from the usual scalar chain rules.</p><h3><a class="nav-anchor" id="Array-addition-1" href="#Array-addition-1">Array addition</a></h3><pre><code class="language-julia">Ω = A + B</code></pre><p>This one is easy:</p><div>\[\Omega = A + B\]</div><div>\[\dot{\Omega} = \dot{A} + \dot{B}\]</div><p>We can implement the <code>frule</code> in ChainRules&#39;s notation:</p><pre><code class="language-julia">function frule(
    (_, ΔA, ΔB),
    ::typeof(+), A::Array{&lt;:RealOrComplex}, B::Array{&lt;:RealOrComplex},
)
    Ω = A + B
    ∂Ω = ΔA + ΔB
    return (Ω, ∂Ω)
end</code></pre><h3><a class="nav-anchor" id="Matrix-multiplication-1" href="#Matrix-multiplication-1">Matrix multiplication</a></h3><pre><code class="language-julia">Ω = A * B</code></pre><div>\[\Omega = A B\]</div><p>First we write in component form:</p><div>\[\Omega_{ij} = \sum_k A_{ik} B_{kj}\]</div><p>Then we use the product rule to get the pushforward for each scalar entry:</p><div>\[\begin{align*}
\dot{\Omega}_{ij}
    &amp;= \sum_k \left( \dot{A}_{ik} B_{kj} + A_{ik} \dot{B}_{kj} \right)
        &amp;&amp; \text{apply scalar product rule }
            \frac{d}{dt}(x y) = \frac{dx}{dt} y + x \frac{dy}{dt} \\
    &amp;= \sum_k \dot{A}_{ik} B_{kj} + \sum_k A_{ik} \dot{B}_{kj}
        &amp;&amp; \text{split sum}
\end{align*}\]</div><p>But the last expression is just the component form of a sum of matrix products:</p><div>\[\begin{equation}\label{diffprod}
\dot{\Omega} = \dot{A} B + A \dot{B}
\end{equation}\]</div><p>This is the matrix product rule, and we write its <code>frule</code> as</p><pre><code class="language-julia">function frule(
    (_, ΔA, ΔB),
    ::typeof(*), A::Matrix{&lt;:RealOrComplex}, B::Matrix{&lt;:RealOrComplex},
)
    Ω = A * B
    ∂Ω = ΔA * B + A * ΔB
    return (Ω, ∂Ω)
end</code></pre><h3><a class="nav-anchor" id="Matrix-inversion-1" href="#Matrix-inversion-1">Matrix inversion</a></h3><pre><code class="language-julia">Ω = inv(A)</code></pre><div>\[\Omega = A^{-1}\]</div><p>It&#39;s easiest to derive this rule from either of the two constraints:</p><div>\[\begin{align*}
\Omega A &amp;= A^{-1} ~A = I\\
A \Omega &amp;= A~ A^{-1} = I,
\end{align*}\]</div><p>where <span>$I$</span> is the identity matrix.</p><p>We use the matrix product rule to differentiate the first constraint:</p><div>\[\dot{\Omega} A + \Omega \dot{A} = 0\]</div><p>Then, right-multiply both sides by <span>$A^{-1}$</span> to isolate <span>$\dot{\Omega}$</span>:</p><div>\[\begin{align}
0  &amp;= \dot{\Omega}~ A~ A^{-1} + \Omega ~\dot{A}~ A^{-1} \nonumber\\
   &amp;= \dot{\Omega}~ I + \Omega ~\dot{A}~ A^{-1}
       &amp;&amp; \text{use } A~ A^{-1} = I \nonumber\\
   &amp;= \dot{\Omega} + \Omega \dot{A} \Omega
       &amp;&amp; \text{substitute } A^{-1} = \Omega \nonumber\\
\dot{\Omega}
   &amp;= -\Omega \dot{A} \Omega
       &amp;&amp; \text{solve for } \dot{\Omega} \label{invdiff}
\end{align}\]</div><p>We write the <code>frule</code> as</p><pre><code class="language-julia">function frule((_, ΔA), ::typeof(inv), A::Matrix{&lt;:RealOrComplex})
    Ω = inv(A)
    ∂Ω = -Ω * ΔA * Ω
    return (Ω, ∂Ω)
end</code></pre><h3><a class="nav-anchor" id="Other-useful-identities-1" href="#Other-useful-identities-1">Other useful identities</a></h3><p>These identities are particularly useful:</p><div>\[\begin{align*}
\frac{d}{dt} \left( \operatorname{real}(A) \right) &amp;= \operatorname{real}(\dot{A})\\
\frac{d}{dt} \left( \operatorname{conj}(A) \right) &amp;= \operatorname{conj}(\dot{A})\\
\frac{d}{dt} \left( A^T \right) &amp;= \dot{A}^T\\
\frac{d}{dt} \left( A^H \right) &amp;= \dot{A}^H\\
\frac{d}{dt} \left( \sum_{j}  A_{i \ldots j \ldots k} \right) &amp;=
    \sum_{j} \dot{A}_{i \ldots j \ldots k},
\end{align*}\]</div><p>where <span>$\cdot^H = \operatorname{conj}(\cdot^T)$</span> is the conjugate transpose (the <code>adjoint</code> function).</p><h2><a class="nav-anchor" id="Reverse-mode-rules-1" href="#Reverse-mode-rules-1">Reverse-mode rules</a></h2><h3><a class="nav-anchor" id="Approach-2" href="#Approach-2">Approach</a></h3><p>Reverse-mode rules are a little less intuitive, but we can re-use our pushforwards to simplify their derivation. Recall our program:</p><div>\[t \mapsto (\ldots, X_m, \ldots) \mapsto \Omega \mapsto s,\]</div><p>At any step in the program, if we have intermediates <span>$X_m$</span>, we can write down the derivative <span>$\frac{ds}{dt}$</span> in terms of the tangents <span>$\dot{X}_m = \frac{dX_m}{dt}$</span> and adjoints <span>$\overline{X}_m = \frac{\partial s}{\partial X_m}$</span></p><div>\[\begin{align*}
\frac{ds}{dt}
    &amp;= \sum_m \operatorname{real}\left( \sum_{i,\ldots,j}
           \operatorname{conj}\left( \frac{\partial s}{\partial (X_m)_{i,\ldots,j}} \right)
           \frac{d (X_m)_{i,\ldots,j}}{dt}
       \right)\\
    &amp;= \sum_m \operatorname{real}\left( \sum_{i,\ldots,j}
           \operatorname{conj} \left( (\overline{X}_m)_{i,\ldots,j} \right)
           (\dot{X}_m)_{i,\ldots,j}
       \right)\\
    &amp;= \sum_m \operatorname{real}\left( \operatorname{dot}\left(
           \overline{X}_m, \dot{X}_m
       \right) \right),
\end{align*}\]</div><p>where <span>$\operatorname{conj}(\cdot)$</span> is the complex conjugate (<code>conj</code>), <span>$\operatorname{real}(\cdot)$</span> is the real part of its argument (<code>real</code>), and <span>$\operatorname{dot}(\cdot, \cdot)$</span> is the inner product (<code>LinearAlgebra.dot</code>). Because this equation follows at any step of the program, we can equivalently write </p><div>\[\frac{ds}{dt} = \operatorname{real}\left( \operatorname{dot}\left(
                    \overline{\Omega}, \dot{\Omega}
                \right) \right),\]</div><p>which gives the identity</p><div>\[\begin{equation} \label{pbident}
\operatorname{real}\left( \operatorname{dot}\left(
    \overline{\Omega}, \dot{\Omega}
\right) \right) = 
\sum_m \operatorname{real}\left( \operatorname{dot}\left(
    \overline{X}_m, \dot{X}_m
\right) \right).
\end{equation}\]</div><p>For matrices and vectors, <span>$\operatorname{dot}(A, B) = \operatorname{tr}(A^H B)$</span>, and the identity simplifies to:</p><div>\[\begin{equation} \label{pbidentmat}
\operatorname{real}\left( \operatorname{tr}\left(
    \overline{\Omega}^H \dot{\Omega}
\right) \right) =
\sum_m \operatorname{real} \left( \operatorname{tr} \left(
    \overline{X}_m^H \dot{X}_m
\right) \right),
\end{equation}\]</div><p>where <span>$\operatorname{tr}(\cdot)$</span> is the matrix trace (<code>LinearAlgebra.tr</code>) function.</p><p>Our approach for deriving the adjoints <span>$\overline{X}_m$</span> is then:</p><ol><li>Derive the pushforward (<span>$\dot{\Omega}$</span> in terms of <span>$\dot{X}_m$</span>) using \eqref{pf}.</li><li>Substitute this expression for <span>$\dot{\Omega}$</span> into the left-hand side of \eqref{pbident}.</li><li>Manipulate until it looks like the right-hand side of \eqref{pbident}.</li><li>Solve for each <span>$\overline{X}_m$</span>.</li></ol><p>Note that the final expressions for the adjoints will not contain any <span>$\dot{X}_m$</span> terms.</p><div class="admonition info"><div class="admonition-title">Info</div><div class="admonition-text"><p>Why do we conjugate, and why do we only use the real part of the dot product in \eqref{pbident}? Recall from <a href="complex.html">Complex Numbers</a> that we treat a complex number as a pair of real numbers. These identities are a direct consequence of this convention. Consider <span>$\frac{ds}{dt}$</span> for a scalar function <span>$f: (x + i y) \mapsto (u + i v)$</span>:</p><div>\[\begin{align*}
\frac{ds}{dt}
    &amp;= \operatorname{real}\left( \operatorname{dot}\left(
           \overline{x} + i \overline{y}, \dot{x} + i \dot{y}
       \right) \right) \\
    &amp;= \operatorname{real}\left(
           \operatorname{conj} \left( \overline{x} + i \overline{y} \right)
           \left( \dot{x} + i \dot{y} \right)
       \right) \\
    &amp;= \operatorname{real}\left(
           \left( \overline{x} - i \overline{y} \right)
           \left( \dot{x} + i \dot{y} \right)
       \right) \\
    &amp;= \operatorname{real}\left(
           \left( \overline{x} \dot{x} + \overline{y} \dot{y} \right) +
           i \left( \overline{x} \dot{y} - \overline{y} \dot{x} \right)
       \right)\\
    &amp;= \overline{x} \dot{x} + \overline{y} \dot{y}\\
\end{align*}\]</div><p>which is exactly what the identity would produce if we had written the function as <span>$f: (x, y) \mapsto (u, v)$</span>.</p></div></div><p>For matrices and vectors, several properties of the trace function come in handy:</p><div>\[\begin{align}
\operatorname{tr}(A+B) &amp;= \operatorname{tr}(A) + \operatorname{tr}(B) \label{trexpand}\\
\operatorname{tr}(A^T) &amp;= \operatorname{tr}(A) \nonumber\\
\operatorname{tr}(A^H) &amp;= \operatorname{conj}(\operatorname{tr}(A)) \nonumber\\
\operatorname{tr}(AB) &amp;= \operatorname{tr}(BA) \label{trperm}
\end{align}\]</div><p>Now let&#39;s derive a few pullbacks using this approach.</p><h3><a class="nav-anchor" id="Matrix-multiplication-2" href="#Matrix-multiplication-2">Matrix multiplication</a></h3><pre><code class="language-julia">Ω = A * B</code></pre><p>We above derived in \eqref{diffprod} the pushforward</p><div>\[\dot{\Omega} = \dot{A} B + A \dot{B}\]</div><p>Using \eqref{pbidentmat}, we now multiply by <span>$\overline{\Omega}^H$</span> and take the real trace:</p><div>\[\begin{align*}
\operatorname{real}\left( \operatorname{tr} \left(
        \overline{\Omega}^H \dot{\Omega}
\right) \right)
    &amp;= \operatorname{real}\left( \operatorname{tr} \left( \overline{\Omega}^H ~\left(
           \dot{A} B + A \dot{B}
       \right) \right) \right)
           &amp;&amp; \text{substitute } \dot{\Omega} \text{ from } \eqref{diffprod}\\
    &amp;= \operatorname{real}\left( \operatorname{tr} \left(
           \overline{\Omega}^H \dot{A} B
       \right) \right) +
       \operatorname{real}\left( \operatorname{tr} \left(
           \overline{\Omega}^H  A \dot{B}
       \right) \right)
           &amp;&amp; \text{expand using } \eqref{trexpand} \\
    &amp;= \operatorname{real}\left( \operatorname{tr} \left(
           B \overline{\Omega}^H \dot{A}
       \right) \right) +
       \operatorname{real}\left( \operatorname{tr} \left(
           \overline{\Omega}^H A \dot{B}
       \right) \right)
           &amp;&amp; \text{rearrange the left term using } \eqref{trperm}\\
    &amp;= \operatorname{real}\left( \operatorname{tr} \left(
           \overline{A}^H  \dot{A}
       \right) \right) +
       \operatorname{real}\left( \operatorname{tr} \left(
           \overline{B}^H \dot{B}
       \right) \right)
           &amp;&amp; \text{right-hand side of } \eqref{pbidentmat}
\end{align*}\]</div><p>That&#39;s it! The expression is in the desired form to solve for the adjoints by comparing the last two lines:</p><div>\[\begin{align*}
B \overline{\Omega}^H \dot{A} &amp;= \overline{A}^H  \dot{A}, \quad
    &amp;&amp; \overline{A} = \overline{\Omega} B^H\\
\overline{\Omega}^H A \dot{B} &amp;= \overline{B}^H \dot{B}, \quad
    &amp;&amp; \overline{B} = A^H \overline{\Omega}
\end{align*}\]</div><p>Using ChainRules&#39;s notation, we would implement the <code>rrule</code> as</p><pre><code class="language-julia">function rrule(::typeof(*), A::Matrix{&lt;:RealOrComplex}, B::Matrix{&lt;:RealOrComplex})
    function times_pullback(ΔΩ)
        ∂A = @thunk(ΔΩ * B&#39;)
        ∂B = @thunk(A&#39; * ΔΩ)
        return (NO_FIELDS, ∂A, ∂B)
    end
    return A * B, times_pullback
end</code></pre><h3><a class="nav-anchor" id="Matrix-inversion-2" href="#Matrix-inversion-2">Matrix inversion</a></h3><pre><code class="language-julia">Ω = inv(A)</code></pre><p>In \eqref{invdiff}, we derived the pushforward as</p><div>\[\dot{\Omega} = -\Omega \dot{A} \Omega\]</div><p>Using \eqref{pbidentmat},</p><div>\[\begin{align*}
\operatorname{real}\left( \operatorname{tr} \left(
    \overline{\Omega}^H \dot{\Omega}
\right) \right)
    &amp;= \operatorname{real}\left( \operatorname{tr} \left(
           -\overline{\Omega}^H \Omega \dot{A} \Omega
       \right) \right)
           &amp;&amp; \text{substitute } \eqref{invdiff}\\
    &amp;= \operatorname{real}\left( \operatorname{tr} \left(
           -\Omega \overline{\Omega}^H \Omega \dot{A}
       \right) \right)
           &amp;&amp; \text{rearrange using } \eqref{trperm}\\
    &amp;= \operatorname{real}\left( \operatorname{tr} \left(
           \overline{A}^H  \dot{A}
       \right) \right)
           &amp;&amp; \text{right-hand side of } \eqref{pbidentmat}
\end{align*}\]</div><p>we can now solve for <span>$\overline{A}$</span>:</p><div>\[\overline{A} = \left( -\Omega \overline{\Omega}^H \Omega \right)^H
             = -\Omega^H \overline{\Omega} \Omega^H\]</div><p>We can implement the resulting <code>rrule</code> as</p><pre><code class="language-julia">function rrule(::typeof(inv), A::Matrix{&lt;:RealOrComplex})
    Ω = inv(A)
    function inv_pullback(ΔΩ)
        ∂A = -Ω&#39; * ΔΩ * Ω&#39;
        return (NO_FIELDS, ∂A)
    end
    return Ω, inv_pullback
end</code></pre><h2><a class="nav-anchor" id="A-multidimensional-array-example-1" href="#A-multidimensional-array-example-1">A multidimensional array example</a></h2><p>We presented the approach for deriving pushforwards and pullbacks for arrays of arbitrary dimensions, so let&#39;s cover an example. For multidimensional arrays, it&#39;s often easier to work in component form. Consider the following function:</p><pre><code class="language-julia">Ω = sum(abs2, X::Array{&lt;:RealOrComplex,3}; dims=2)::Array{&lt;:Real,3}</code></pre><p>which we write as</p><div>\[\Omega_{i1k} = \sum_{j} |X_{ijk}|^2
             = \sum_{j} \operatorname{real} \left(
                  \operatorname{conj} \left( X_{ijk} \right) X_{ijk}
               \right)\]</div><p>The pushforward from \eqref{pf} is</p><div>\[\begin{align}
\dot{\Omega}_{i1k}
    &amp;= \sum_j \operatorname{real}\left(
           \operatorname{conj} \left( \dot{X}_{ijk} \right) X_{ijk} +
           \operatorname{conj} \left( X_{ijk} \right) \dot{X}_{ijk} \right) \nonumber\\
    &amp;= \sum_j \operatorname{real}\left(
            \operatorname{conj}\left(
                \operatorname{conj} \left( X_{ijk} \right) \dot{X}_{ijk}
            \right) +
            \operatorname{conj}(X_{ijk}) \dot{X}_{ijk}
       \right) \nonumber\\
    &amp;= \sum_j 2 \operatorname{real}\left(
           \operatorname{conj} \left( X_{ijk} \right) \dot{X}_{ijk}
       \right), \label{sumabspf}
\end{align}\]</div><p>where in the last step we have used the fact that for all real <span>$a$</span> and <span>$b$</span>,</p><div>\[(a + i b) + \operatorname{conj}(a + i b)
    = (a + i b) + (a - i b)
    = 2 a
    = 2 \operatorname{real} (a + i b).\]</div><p>Because none of this derivation depended on the index (or indices), we implement <code>frule</code> generically as</p><pre><code class="language-julia">function frule(
    (_, _, ΔX),
    ::typeof(sum), ::typeof(abs2), X::Array{&lt;:RealOrComplex};
    dims = :,
)
    Ω = sum(abs2, X; dims = dims)
    ∂Ω = sum(2 .* real.(conj.(X) .* ΔX); dims = dims)
    return (Ω, ∂Ω)
end</code></pre><p>We can now derive the reverse-mode rule. The array form of \eqref{pbident} is</p><div>\[\begin{align*}
\operatorname{real}\left( \operatorname{dot}\left(
    \overline{\Omega}, \dot{\Omega}
\right) \right)
    &amp;= \operatorname{real} \left( \sum_{ik}
           \operatorname{conj} \left( \overline{\Omega}_{i1k} \right) \dot{\Omega}_{i1k}
       \right)
           &amp;&amp; \text{expand left-hand side of } \eqref{pbident}\\
    &amp;= \operatorname{real} \left(\sum_{ijk}
           \operatorname{conj} \left( \overline{\Omega}_{i1k} \right)
           2 \operatorname{real}\left(
               \operatorname{conj} \left( X_{ijk} \right) \dot{X}_{ijk}
           \right)
       \right)
           &amp;&amp; \text{substitute } \eqref{sumabspf}\\
    &amp;= \operatorname{real} \left( \sum_{ijk}
           \left(
               2 \operatorname{real} \left( \overline{\Omega}_{i1k} \right)
               \operatorname{conj} \left( X_{ijk} \right)
           \right) \dot{X}_{ijk}
       \right)
           &amp;&amp; \text{bring } \dot{X}_{ijk} \text{ outside of } \operatorname{real}\\
    &amp;= \operatorname{real} \left( \sum_{ijk}
           \operatorname{conj} \left( \overline{X}_{ijk} \right) \dot{X}_{i1k}
       \right)
           &amp;&amp; \text{expand right-hand side of } \eqref{pbident}
\end{align*}\]</div><p>We now solve for <span>$\overline{X}$</span>:</p><div>\[\begin{align*}
\overline{X}_{ijk}
    &amp;= \operatorname{conj}\left(
            2 \operatorname{real} \left( \overline{\Omega}_{i1k} \right)
            \operatorname{conj} \left( X_{ijk} \right)
        \right)\\
    &amp;= 2\operatorname{real} \left( \overline{\Omega}_{i1k} \right) X_{ijk}
\end{align*}\]</div><p>Like the <code>frule</code>, this <code>rrule</code> can be implemented generically:</p><pre><code class="language-julia">function rrule(::typeof(sum), ::typeof(abs2), X::Array{&lt;:RealOrComplex}; dims = :)
    function sum_abs2_pullback(ΔΩ)
        ∂abs2 = DoesNotExist()
        ∂X = @thunk(2 .* real.(ΔΩ) .* X)
        return (NO_FIELDS, ∂abs2, ∂X)
    end
    return sum(abs2, X; dims = dims), sum_abs2_pullback
end</code></pre><h2><a class="nav-anchor" id="More-examples-1" href="#More-examples-1">More examples</a></h2><p>For more instructive examples of array rules, see <a href="#footnote-Giles2008ext">[Giles2008ext]</a> (real vector and matrix rules) and the <a href="https://github.com/JuliaDiff/ChainRules.jl/tree/master/src/rulesets/LinearAlgebra">LinearAlgebra rules in ChainRules</a>.</p><h2><a class="nav-anchor" id="References-1" href="#References-1">References</a></h2><div class="footnote" id="footnote-Giles2008"><a href="#footnote-Giles2008"><strong>[Giles2008]</strong></a><blockquote><p>Giles M. B. Collected Matrix Derivative Results for Forward and Reverse Mode Algorithmic Differentiation. In: Advances in Automatic Differentiation. <em>Lecture Notes in Computational Science and Engineering</em>, vol 64: pp 35-44. Springer, Berlin (2008). doi: <a href="https://doi.org/10.1007/978-3-540-68942-3_4">10.1007/978-3-540-68942-3_4</a>. <a href="https://people.maths.ox.ac.uk/gilesm/files/AD2008.pdf">pdf</a></p></blockquote></div><div class="footnote" id="footnote-Giles2008ext"><a href="#footnote-Giles2008ext"><strong>[Giles2008ext]</strong></a><blockquote><p>Giles M. B. An Extended Collection of Matrix Derivative Results for Forward and Reverse Mode Algorithmic Differentiation. (unpublished). <a href="https://people.maths.ox.ac.uk/gilesm/files/NA-08-01.pdf">pdf</a></p></blockquote></div><footer><hr/><a class="previous" href="complex.html"><span class="direction">Previous</span><span class="title">Complex Numbers</span></a><a class="next" href="debug_mode.html"><span class="direction">Next</span><span class="title">Debug Mode</span></a></footer></article></body></html>
