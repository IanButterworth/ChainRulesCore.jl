<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Deriving Array Rules · ChainRules</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><link href="assets/chainrules.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.svg" alt="ChainRules logo"/></a><h1>ChainRules</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li><a class="toctext" href="FAQ.html">FAQ</a></li><li><a class="toctext" href="writing_good_rules.html">Writing Good Rules</a></li><li><a class="toctext" href="complex.html">Complex Numbers</a></li><li class="current"><a class="toctext" href="arrays.html">Deriving Array Rules</a><ul class="internal"><li><a class="toctext" href="#Deriving-forward-mode-rules-1">Deriving forward-mode rules</a></li><li><a class="toctext" href="#Deriving-reverse-mode-rules-1">Deriving reverse-mode rules</a></li><li><a class="toctext" href="#More-examples-1">More examples</a></li><li><a class="toctext" href="#Generalizing-to-multidimensional-arrays-1">Generalizing to multidimensional arrays</a></li><li><a class="toctext" href="#References-1">References</a></li></ul></li><li><a class="toctext" href="debug_mode.html">Debug Mode</a></li><li><span class="toctext">Design</span><ul><li><a class="toctext" href="design/many_differentials.html">Many Differential Types</a></li></ul></li><li><a class="toctext" href="api.html">API</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="arrays.html">Deriving Array Rules</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/master/docs/src/arrays.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Deriving Array Rules</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Deriving-Array-Rules-1" href="#Deriving-Array-Rules-1">Deriving Array Rules</a></h1><p>When the inputs and outputs of the functions are arrays (potentially with scalars), a modified version of Giles&#39; method is a quick way of deriving <a href="api.html#ChainRulesCore.frule-Tuple{Any,Vararg{Any,N} where N}"><code>frule</code></a>s and <a href="api.html#ChainRulesCore.rrule-Tuple{Any,Vararg{Any,N} where N}"><code>rrule</code></a>s. Giles&#39; method is succinctly explained in <a href="#footnote-Giles2008">[Giles2008]</a> and its extended work <a href="#footnote-Giles2008ext">[Giles2008ext]</a>, but we will generalize it to handle arrays with both real and complex entries and arrays of arbitrary dimensions.</p><p>Throughout this tutorial, we will ust the following type alias</p><pre><code class="language-julia">const RealOrComplex = Union{Real,Complex}</code></pre><h2><a class="nav-anchor" id="Deriving-forward-mode-rules-1" href="#Deriving-forward-mode-rules-1">Deriving forward-mode rules</a></h2><p>Given a function</p><pre><code class="language-julia">C = f(A::Array{&lt;:RealOrComplex}, B::Array{&lt;:RealOrComplex})::Array{&lt;:RealOrComplex}</code></pre><p>we write the differential of the output in terms of differentials of the inputs as</p><div>\[\begin{equation}\label{cdiff}
dC = \frac{\partial f}{\partial A} dA + \frac{\partial f}{\partial B} dB.
\end{equation}\]</div><p>Notationally, we write the pushforward by replacing the differentials with the corresponding forward-mode sensitivities (e.g. replace <span>$dC$</span> with <span>$\dot{C}$</span>):</p><div>\[\dot{C} = \frac{\partial f}{\partial A} \dot{A} + \frac{\partial f}{\partial B} \dot{B}.\]</div><p>The terms <span>$\frac{\partial f}{\partial A}$</span> are array-array derivatives (i.e. a type of Jacobian). We do not write these down explicitly, but we instead use differential identities to derive the terms <span>$\frac{\partial f}{\partial A} dA$</span>, which as we&#39;ve seen behave like the Jacobian-vector-products <span>$\frac{\partial f}{\partial A} \dot{A}$</span>. The differential identities follow directly from the usual scalar identities. We will look at a few examples.</p><h3><a class="nav-anchor" id="Matrix-addition-1" href="#Matrix-addition-1">Matrix addition</a></h3><pre><code class="language-julia">C = A + B</code></pre><p>This one is easy:</p><div>\[C = A + B\]</div><div>\[dC = dA + dB\]</div><p>We can implement the <code>frule</code> in ChainRules` notation:</p><pre><code class="language-julia">function frule(
    (_, ΔA, ΔB),
    ::typeof(+), A::Array{&lt;:RealOrComplex}, B::Array{&lt;:RealOrComplex},
)
    return (A + B, ΔA + ΔB)
end</code></pre><h3><a class="nav-anchor" id="Matrix-multiplication-1" href="#Matrix-multiplication-1">Matrix multiplication</a></h3><pre><code class="language-julia">C = A * B</code></pre><div>\[C = A B\]</div><p>First we write in component form:</p><div>\[C_{ij} = \sum_k A_{ik} B_{kj}\]</div><p>Then we use the product rule to get the scalar differential identity:</p><div>\[\begin{align*}
dC_{ij} &amp;= \sum_k \left( dA_{ik}~ B_{kj} + A_{ik} ~dB_{kj} \right)
            &amp;&amp; \text{apply scalar product rule } d(x y) = dx~ y + x ~dy \\
        &amp;= \sum_k dA_{ik}~ B_{kj} + \sum_k A_{ik} ~dB_{kj}
            &amp;&amp; \text{expand sum}
\end{align*}\]</div><p>But the last expression is just a sum of matrix products:</p><div>\[\begin{equation}\label{diffprod}
dC = dA~ B + A ~dB
\end{equation}\]</div><p>This is the matrix product rule, whose <code>frule</code> is</p><pre><code class="language-julia">function frule(
    (_, ΔA, ΔB),
    ::typeof(*), A::Matrix{&lt;:RealOrComplex}, B::Matrix{&lt;:RealOrComplex},
)
    return (A * B, ΔA * B + A * ΔB)
end</code></pre><h3><a class="nav-anchor" id="Matrix-inversion-1" href="#Matrix-inversion-1">Matrix inversion</a></h3><pre><code class="language-julia">C = inv(A)</code></pre><div>\[C = A^{-1}\]</div><p>It&#39;s easiest to derive this rule from either constraint:</p><div>\[\begin{align*}
C A &amp;= A^{-1} ~A = I\\
A C &amp;= A~ A^{-1} = I,
\end{align*}\]</div><p>where <span>$I$</span> is the identity matrix.</p><p>We use the matrix product rule to differentiate the first constraint:</p><div>\[dC~ A + C ~dA = 0\]</div><p>We right-multiply both sides by <span>$A^{-1}$</span> to isolate <span>$dC$</span>:</p><div>\[\begin{align}
0  &amp;= dC~ A~ A^{-1} + C ~dA~ A^{-1} &amp;&amp; \nonumber\\
   &amp;= dC~ I + C ~dA~ A^{-1} &amp;&amp; \text{apply } A~ A^{-1} = I \nonumber\\
   &amp;= dC + C ~dA~ C &amp;&amp; \text{substitute } A^{-1} = C \nonumber\\
dC &amp;= -C ~dA~ C &amp;&amp; \text{solve for } dC \label{invdiff}
\end{align}\]</div><p>We write the <code>frule</code> as</p><pre><code class="language-julia">function frule((_, ΔA), ::typeof(inv), A::Matrix{&lt;:RealOrComplex})
    C = inv(A)
    ∂C = -C * ΔA * C
    return (C, ∂C)
end</code></pre><h3><a class="nav-anchor" id="Other-useful-identities-1" href="#Other-useful-identities-1">Other useful identities</a></h3><p>These identities are particularly useful:</p><div>\[\begin{align*}
d\left( \operatorname{real}(A) \right) &amp;= \operatorname{real}(dA)\\
d\left( \operatorname{conj}(A) \right) &amp;= \operatorname{conj}(dA)\\
d\left( A^T \right) &amp;= dA^T\\
d\left( A^H \right) &amp;= dA^H\\
d\left( \sum_{j}  A_{i \ldots j \ldots k} \right) &amp;=
        \sum_{j} dA_{i \ldots j \ldots k},
\end{align*}\]</div><p>where <span>$\cdot^H$</span> is the conjugate transpose (the <code>adjoint</code> function).</p><h2><a class="nav-anchor" id="Deriving-reverse-mode-rules-1" href="#Deriving-reverse-mode-rules-1">Deriving reverse-mode rules</a></h2><p>Reverse-mode rules are a little more involved. For a real scalar function <span>$s = g(C)$</span>, the differential of <span>$s$</span> is the real part of the inner product (<code>LinearAlgebra.dot</code>) of the adjoint of <span>$C$</span> (i.e. <span>$\overline{C}$</span>), and the differential of <span>$C$</span>:</p><div>\[ds = \operatorname{real}\left( \langle \overline{C}, dC \rangle \right)
   = \operatorname{real}\left(
         \sum_{i,\dots,j} \operatorname{conj}(\overline{C}_{i,\dots,j}) ~dC_{i,\dots,j}
     \right),\]</div><p>where <span>$\operatorname{conj}(\cdot)$</span> is the complex conjugate (<code>conj</code>), and <span>$\operatorname{real}(\cdot)$</span> is the real part of its argument (<code>real</code>).</p><p>For matrices and vectors, we can write this as</p><div>\[ds = \operatorname{real}(\operatorname{tr}(\overline{C}^H dC)),\]</div><p>where <span>$\operatorname{tr}$</span> is the matrix trace (<code>LinearAlgebra.tr</code>) function.</p><p>We can write the corresponding expression for <span>$dA$</span> and <span>$dB$</span> as</p><div>\[\begin{align*}
ds &amp;= \operatorname{real}(\operatorname{tr}(\overline{C}^H dC)) &amp;&amp;\\
   &amp;= \operatorname{real}\left( \operatorname{tr}\left(
          \overline{C}^H \frac{\partial f}{\partial A} dA +
          \overline{C}^H \frac{\partial f}{\partial B} dB
      \right) \right) &amp;&amp; \text{substitute } dC \text{ from } \eqref{cdiff}\\
   &amp;= \operatorname{real}\left( \operatorname{tr}\left(
          \overline{C}^H \frac{\partial f}{\partial A} dA
      \right) \right) +
      \operatorname{real}\left( \operatorname{tr}\left(
          \overline{C}^H \frac{\partial f}{\partial B} dB
      \right) \right) &amp;&amp; \text{expand using } \eqref{trexpand}
\end{align*}\]</div><p>By applying the same definition of <span>$ds$</span> to the intermediates <span>$A$</span> and <span>$B$</span>, we get</p><div>\[ds = \operatorname{real}\left( \operatorname{tr}(\overline{A}^H  dA) \right) +
     \operatorname{real}\left( \operatorname{tr}(\overline{B}^H ~dB) \right)\]</div><p>Combining these two identities and solving for <span>$\overline{A}$</span> and <span>$\overline{B}$</span> gives us</p><div>\[\begin{align*}
    \overline{A} &amp;= (\overline{A}^H)^H
                  = \left( \overline{C}^H \frac{\partial f}{\partial A} \right)^H
                  = \left( \frac{\partial f}{\partial A} \right)^H \overline{C}\\
    \overline{B} &amp;= \left( \frac{\partial f}{\partial B} \right)^H \overline{C}
\end{align*}\]</div><p>Giles&#39; method for deriving pullback functions is to first derive the differential identity (i.e. pushforward) using the above approach, then pre-multiply by <span>$\overline{C}^H$</span>, and take the real trace. Subsequently, manipulate into this form and solve for the adjoint derivatives of the inputs. Several properties of the trace function make this easier:</p><div>\[\begin{align}
    \operatorname{tr}(A+B) &amp;= \operatorname{tr}(A) + \operatorname{tr}(B) \label{trexpand}\\
    \operatorname{tr}(A^T) &amp;= \operatorname{tr}(A) \nonumber\\
    \operatorname{tr}(A^H) &amp;= \operatorname{conj}(\operatorname{tr}(A)) \nonumber\\
    \operatorname{tr}(AB) &amp;= \operatorname{tr}(BA) \label{trperm}
\end{align}\]</div><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Our method is identical to Giles&#39; approach, except we have replace the transpose with the conjugate transpose, and we have added the constraint that the inner product be real. This produces the correct pullbacks for arrays with complex entries.</p></div></div><p>Here are a few examples.</p><h3><a class="nav-anchor" id="Matrix-multiplication-2" href="#Matrix-multiplication-2">Matrix multiplication</a></h3><pre><code class="language-julia">C = A * B</code></pre><p>We above derived in \eqref{diffprod} the differential identity</p><div>\[dC = dA~ B + A ~dB\]</div><p>We now multiply by <span>$\overline{C}^H$</span> and take the real trace:</p><div>\[\begin{align*}
ds &amp;= \operatorname{real}\left( \operatorname{tr}(\overline{C}^H ~dC) \right) &amp;&amp;\\
   &amp;= \operatorname{real}\left( \operatorname{tr}(\overline{C}^H ~\left(
          dA~ B + A ~dB
      \right)) \right) &amp;&amp;
        \text{substitute } dC \text{ from } \eqref{diffprod}\\
   &amp;= \operatorname{real}\left( \operatorname{tr}(\overline{C}^H ~dA~ B) \right) +
      \operatorname{real}\left( \operatorname{tr}(\overline{C}^H  A ~dB) \right) &amp;&amp;
        \text{expand using } \eqref{trexpand} \\
   &amp;= \operatorname{real}\left( \operatorname{tr}(B \overline{C}^H ~dA) \right) +
      \operatorname{real}\left( \operatorname{tr}(\overline{C}^H A ~dB) \right) &amp;&amp;
        \text{rearrange the left side using } \eqref{trperm}\\
   &amp;= \operatorname{real}\left( \operatorname{tr}(\overline{A}^H  dA) \right) +
      \operatorname{real}\left( \operatorname{tr}(\overline{B}^H ~dB) \right) &amp;&amp; \\
\end{align*}\]</div><p>That&#39;s it! The expression is in the desired form to solve for the adjoints:</p><div>\[\begin{align*}
    \overline{A} &amp;= \left( \overline{A}^H \right)^H
                  = \left( B \overline{C}^H \right)^H = \overline{C} B^H\\
    \overline{B} &amp;= \left( \overline{B}^H \right)^H
                  = \left( \overline{C}^H A \right)^H = A^H \overline{C}
\end{align*}\]</div><p>Using ChainRules&#39; notation, we would implement the <code>rrule</code> as</p><pre><code class="language-julia">function rrule(::typeof(*), A::Matrix{&lt;:RealOrComplex}, B::Matrix{&lt;:RealOrComplex})
    function times_pullback(ΔC)
        ∂A = @thunk(ΔC * B&#39;)
        ∂B = @thunk(A&#39; * ΔC)
        return (NO_FIELDS, ∂A, ∂B)
    end
    return A * B, times_pullback
end</code></pre><h3><a class="nav-anchor" id="Matrix-inversion-2" href="#Matrix-inversion-2">Matrix inversion</a></h3><pre><code class="language-julia">C = inv(A)</code></pre><p>In \eqref{invdiff}, we derived the differential identity as</p><div>\[dC = -C ~dA~ C\]</div><p>Multiplying by <span>$\overline{C}^H$</span> and taking the real trace,</p><div>\[    ds = \operatorname{real}\left( \operatorname{tr}(\overline{C}^H ~dC) \right)
       = \operatorname{real}\left( \operatorname{tr}(-\overline{C}^H C ~dA~ C) \right)\]</div><p>Applying the trace identity \eqref{trperm} to manipulate into the desired form,</p><div>\[ds = \operatorname{real}(\operatorname{tr}(-C \overline{C}^H C ~dA) ),\]</div><p>we can now solve for <span>$\overline{A}$</span>:</p><div>\[\overline{A} = (-C \overline{C}^H C)^H = -C^H \overline{C} C^H\]</div><p>We can implement the resulting <code>rrule</code> as:</p><pre><code class="language-julia">function rrule(::typeof(inv), A::Matrix{&lt;:RealOrComplex})
    C = inv(A)
    function inv_pullback(ΔC)
        ∂A = -C&#39; * ΔC * C&#39;
        return (NO_FIELDS, ∂A)
    end
    return C, inv_pullback
end</code></pre><h2><a class="nav-anchor" id="More-examples-1" href="#More-examples-1">More examples</a></h2><p>For more instructive examples of matrix and vector rules, see <a href="#footnote-Giles2008ext">[Giles2008ext]</a> and the <a href="https://github.com/JuliaDiff/ChainRules.jl/tree/master/src/rulesets/LinearAlgebra">LinearAlgebra rules in ChainRules</a>.</p><h2><a class="nav-anchor" id="Generalizing-to-multidimensional-arrays-1" href="#Generalizing-to-multidimensional-arrays-1">Generalizing to multidimensional arrays</a></h2><p>For both forward- and reverse-mode rules for matrices, the first step was to write down the differential identities, which followed directly from the scalar differential identities. This approach follows for arrays, but it&#39;s easier to work in component form. Consider the following function</p><pre><code class="language-julia">C = sum(abs2, A::Array{&lt;:RealOrComplex,3}; dims=2)::Array{&lt;:Real,3}</code></pre><p>which we write as</p><div>\[C_{i1k} = \sum_{j} |A_{ijk}|^2 = \sum_{j} \operatorname{real}(\operatorname{conj}(A_{ijk}) A_{ijk})\]</div><p>The differential identity is</p><div>\[\begin{align*}
    dC_{i1k} &amp;= \sum_j \operatorname{real}( \operatorname{conj}(dA_{ijk})~ A_{ijk} +
                            \operatorname{conj}(A_{ijk}) ~dA_{ijk} ) \\
             &amp;= \sum_j \operatorname{real}(
                    \operatorname{conj}\left(
                        \operatorname{conj}(A_{ijk}) ~dA_{ijk}
                    \right) +
                        \operatorname{conj}(A_{ijk}) ~dA_{ijk}
                )\\
             &amp;= \sum_j 2 \operatorname{real}( \operatorname{conj}(A_{ijk}) ~dA_{ijk} )
\end{align*}\]</div><p>where in the last step we have used the fact that for all real <span>$a$</span> and <span>$b$</span>,</p><div>\[(a + i b) + \operatorname{conj}(a + i b) = (a + i b) + (a - i b) = 2 a = 2 \operatorname{real} (a + i b).\]</div><p>The <code>frule</code> can be implemented generally as</p><pre><code class="language-julia">function frule(
    (_, _, ΔA),
    ::typeof(sum), ::typeof(abs2), A::Array{&lt;:RealOrComplex};
    dims = :,
)
    C = sum(abs2, A; dims = dims)
    ∂C = sum(2 .* real.(conj.(A) .* ΔA); dims = dims)
    return (C, ∂C)
end</code></pre><p>We can now derive the reverse-mode rule. The array form of the desired identity will be</p><div>\[ds = \operatorname{real} \left( \sum_{ik}  \operatorname{conj}(\overline{C}_{i1k}) ~dC_{i1k} \right)
   = \operatorname{real} \left( \sum_{ijk} \operatorname{conj}(\overline{A}_{ijk}) ~dA_{ijk} \right)\]</div><p>We plug the differential identity into the middle expression to get</p><div>\[\begin{align*}
    ds &amp;= \operatorname{real} \left(\sum_{ijk}
                  \operatorname{conj}(\overline{C}_{i1k})
                  2 \operatorname{real}(\operatorname{conj}(A_{ijk}) ~dA_{ijk})
              \right) \\
       &amp;= \operatorname{real} \left( \sum_{ijk}
              2 \operatorname{real}(\overline{C}_{i1k})
              \operatorname{conj}(A_{ijk}) ~dA_{ijk}
          \right).
\end{align*}\]</div><p>We now solve for <span>$\overline{A}$</span>:</p><div>\[\overline{A}_{ijk} = \operatorname{conj}(
                         2 \operatorname{real}( \overline{C}_{i1k} )
                         \operatorname{conj}(A_{ijk})
                     )
                   = 2\operatorname{real}( \overline{C}_{i1k} ) A_{ijk}\]</div><p>Because none of this derivation really depended on the index (or indices), we can easily implement the <code>rrule</code> more generically using broadcasting:</p><pre><code class="language-julia">function rrule(::typeof(sum), ::typeof(abs2), A::Array{&lt;:RealOrComplex}; dims = :)
    function sum_abs2_pullback(ΔC)
        ∂abs2 = DoesNotExist()
        ∂A = @thunk(2 .* real.(ΔC) .* A)
        return (NO_FIELDS, ∂abs2, ∂A)
    end
    return sum(abs2, A; dims = dims), sum_abs2_pullback
end</code></pre><h2><a class="nav-anchor" id="References-1" href="#References-1">References</a></h2><div class="footnote" id="footnote-Giles2008"><a href="#footnote-Giles2008"><strong>[Giles2008]</strong></a><blockquote><p>Giles M. B. Collected Matrix Derivative Results for Forward and Reverse Mode Algorithmic Differentiation. In: Advances in Automatic Differentiation. <em>Lecture Notes in Computational Science and Engineering</em>, vol 64: pp 35-44. Springer, Berlin (2008). doi: <a href="https://doi.org/10.1007/978-3-540-68942-3_4">10.1007/978-3-540-68942-3_4</a>. <a href="https://people.maths.ox.ac.uk/gilesm/files/AD2008.pdf">pdf</a></p></blockquote></div><div class="footnote" id="footnote-Giles2008ext"><a href="#footnote-Giles2008ext"><strong>[Giles2008ext]</strong></a><blockquote><p>Giles M. B. An Extended Collection of Matrix Derivative Results for Forward and Reverse Mode Algorithmic Differentiation. (unpublished). <a href="https://people.maths.ox.ac.uk/gilesm/files/NA-08-01.pdf">pdf</a></p></blockquote></div><footer><hr/><a class="previous" href="complex.html"><span class="direction">Previous</span><span class="title">Complex Numbers</span></a><a class="next" href="debug_mode.html"><span class="direction">Next</span><span class="title">Debug Mode</span></a></footer></article></body></html>
