<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · ChainRules</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><link href="assets/chainrules.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.svg" alt="ChainRules logo"/></a><h1>ChainRules</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li><a class="toctext" href="FAQ.html">FAQ</a></li><li><a class="toctext" href="writing_good_rules.html">Writing Good Rules</a></li><li class="current"><a class="toctext" href="api.html">API</a><ul class="internal"></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="api.html">API</a></li></ul><a class="edit-page" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/master/docs/src/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="API-Documentation-1" href="#API-Documentation-1">API Documentation</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.NO_FIELDS" href="#ChainRulesCore.NO_FIELDS"><code>ChainRulesCore.NO_FIELDS</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-julia">NO_FIELDS</code></pre><p>Constant for the reverse-mode derivative with respect to a structure that has no fields. The most notable use for this is for the reverse-mode derivative with respect to the function itself, when that function is not a closure.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/5e6eb715f64171fcd182039c144617fb9fdbf126/src/differentials/composite.jl#L256-L262">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.AbstractZero" href="#ChainRulesCore.AbstractZero"><code>ChainRulesCore.AbstractZero</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">AbstractZero &lt;: AbstractDifferential</code></pre><p>This is zero-like differential types. If a AD system encounter a propagator taking as input only subtypes of <code>AbstractZero</code> then it can stop performing any AD operations, as all propagator are linear functions, and thus the final result will be zero.</p><p>All <code>AbstractZero</code> subtypes are singleton types. There are two of them <a href="api.html#ChainRulesCore.Zero"><code>Zero()</code></a> and <a href="api.html#ChainRulesCore.DoesNotExist"><code>DoesNotExist()</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/5e6eb715f64171fcd182039c144617fb9fdbf126/src/differentials/abstract_zero.jl#L1-L11">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.Composite" href="#ChainRulesCore.Composite"><code>ChainRulesCore.Composite</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Composite{P, T} &lt;: AbstractDifferential</code></pre><p>This type represents the differential for a <code>struct</code>/<code>NamedTuple</code>, or <code>Tuple</code>. <code>P</code> is the the corresponding primal type that this is a differential for.</p><p><code>Composite{P}</code> should have fields (technically properties), that match to a subset of the fields of the primal type; and each should be a differential type matching to the primal type of that field. Fields of the P that are not present in the Composite are treated as <code>Zero</code>.</p><p><code>T</code> is an implementation detail representing the backing data structure. For Tuple it will be a Tuple, and for everything else it will be a <code>NamedTuple</code>. It should not be passed in by user.</p><p>For <code>Composite</code>s of <code>Tuple</code>s, <code>iterate</code> and <code>getindex</code> are overloaded to behave similarly to for a tuple. For <code>Composite</code>s of <code>struct</code>s, <code>getproperty</code> is overloaded to allow for accessing values via <code>comp.fieldname</code>. Any fields not explictly present in the <code>Composite</code> are treated as being set to <code>Zero()</code>. To make a <code>Composite</code> have all the fields of the primal the <a href="api.html#ChainRulesCore.canonicalize-Union{Tuple{Composite{P,#s14} where #s14&lt;:(NamedTuple{L,T} where T&lt;:Tuple)}, Tuple{L}, Tuple{P}} where L where P"><code>canonicalize</code></a> function is provided.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/5e6eb715f64171fcd182039c144617fb9fdbf126/src/differentials/composite.jl#L1-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.DoesNotExist" href="#ChainRulesCore.DoesNotExist"><code>ChainRulesCore.DoesNotExist</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">DoesNotExist() &lt;: AbstractZero</code></pre><p>This differential indicates that the derivative does not exist. It is the differential for a Primal type that is not differentiable. Such an Integer, or Boolean (when not being used as a represention of a value that normally would be a floating point.) The only valid way to pertube such a values is to not change it at all. As such, <code>DoesNotExist</code> is functionally identical to <code>Zero()</code>, but provides additional semantic information.</p><p>If you are adding this differential to a primal then something is wrong. A optimization package making use of this might like to check for such a case.</p><p>!!! note:     This does not indicate that the derivative it is not implemented,     but rather that mathematically it is not defined.</p><p>This mostly shows up as the deriviative with respect to dimension, index, or size arguments.</p><pre><code class="language-none">    function rrule(fill, x, len::Int)
        y = fill(x, len)
        fill_pullback(ȳ) = (NO_FIELDS, @thunk(sum(Ȳ)), DoesNotExist())
        return y, fill_pullback
    end</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/5e6eb715f64171fcd182039c144617fb9fdbf126/src/differentials/abstract_zero.jl#L39-L66">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.InplaceableThunk" href="#ChainRulesCore.InplaceableThunk"><code>ChainRulesCore.InplaceableThunk</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">InplaceableThunk(val::Thunk, add!::Function)</code></pre><p>A wrapper for a <code>Thunk</code>, that allows it to define an inplace <code>add!</code> function.</p><p><code>add!</code> should be defined such that: <code>ithunk.add!(Δ) = Δ .+= ithunk.val</code> but it should do this more efficently than simply doing this directly. (Otherwise one can just use a normal <code>Thunk</code>).</p><p>Most operations on an <code>InplaceableThunk</code> treat it just like a normal <code>Thunk</code>; and destroy its inplacability.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/5e6eb715f64171fcd182039c144617fb9fdbf126/src/differentials/thunks.jl#L107-L118">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.One" href="#ChainRulesCore.One"><code>ChainRulesCore.One</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia"> One()</code></pre><p>The Differential which is the multiplicative identity. Basically, this represents <code>1</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/5e6eb715f64171fcd182039c144617fb9fdbf126/src/differentials/one.jl#L1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.Thunk" href="#ChainRulesCore.Thunk"><code>ChainRulesCore.Thunk</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Thunk(()-&gt;v)</code></pre><p>A thunk is a deferred computation. It wraps a zero argument closure that when invoked returns a differential. <code>@thunk(v)</code> is a macro that expands into <code>Thunk(()-&gt;v)</code>.</p><p>Calling a thunk, calls the wrapped closure. <code>extern</code>ing thunks applies recursively, it also externs the differial that the closure returns. If you do not want that, then simply call the thunk</p><pre><code class="language-none">julia&gt; t = @thunk(@thunk(3))
Thunk(var&quot;##7#9&quot;())

julia&gt; extern(t)
3

julia&gt; t()
Thunk(var&quot;##8#10&quot;())

julia&gt; t()()
3</code></pre><p><strong>When to <code>@thunk</code>?</strong></p><p>When writing <code>rrule</code>s (and to a lesser exent <code>frule</code>s), it is important to <code>@thunk</code> appropriately. Propagation rules that return multiple derivatives may not have all deriviatives used.  By <code>@thunk</code>ing the work required for each derivative, they then compute only what is needed.</p><p><strong>How do thunks prevent work?</strong></p><p>If we have <code>res = pullback(...) = @thunk(f(x)), @thunk(g(x))</code> then if we did <code>dx + res[1]</code> then only <code>f(x)</code> would be evaluated, not <code>g(x)</code>. Also if we did <code>Zero() * res[1]</code> then the result would be <code>Zero()</code> and <code>f(x)</code> would not be evaluated.</p><p><strong>So why not thunk everything?</strong></p><p><code>@thunk</code> creates a closure over the expression, which (effectively) creates a <code>struct</code> with a field for each variable used in the expression, and call overloaded.</p><p>Do not use <code>@thunk</code> if this would be equal or more work than actually evaluating the expression itself. Examples being:</p><ul><li>The expression being a constant</li><li>The expression is merely wrapping something in a <code>struct</code>, such as <code>Adjoint(x)</code> or <code>Diagonal(x)</code></li><li>The expression being itself a <code>thunk</code></li><li>The expression being from another <code>rrule</code> or <code>frule</code>; it would be <code>@thunk</code>ed if required by the defining rule already.</li><li>There is only one derivative being returned, so from the fact that the user called <code>frule</code>/<code>rrule</code> they clearly will want to use that one.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/5e6eb715f64171fcd182039c144617fb9fdbf126/src/differentials/thunks.jl#L20-L68">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.Zero" href="#ChainRulesCore.Zero"><code>ChainRulesCore.Zero</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Zero() &lt;: AbstractZero</code></pre><p>The additive identity for differentials. This is basically the same as <code>0</code>. A derivative of <code>Zero()</code>. does not propagate through the primal function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/5e6eb715f64171fcd182039c144617fb9fdbf126/src/differentials/abstract_zero.jl#L26-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.canonicalize-Union{Tuple{Composite{P,#s14} where #s14&lt;:(NamedTuple{L,T} where T&lt;:Tuple)}, Tuple{L}, Tuple{P}} where L where P" href="#ChainRulesCore.canonicalize-Union{Tuple{Composite{P,#s14} where #s14&lt;:(NamedTuple{L,T} where T&lt;:Tuple)}, Tuple{L}, Tuple{P}} where L where P"><code>ChainRulesCore.canonicalize</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">canonicalize(comp::Composite{P}) -&gt; Composite{P}</code></pre><p>Return the canonical <code>Composite</code> for the primal type <code>P</code>. The property names of the returned <code>Composite</code> match the field names of the primal, and all fields of <code>P</code> not present in the input <code>comp</code> are explictly set to <code>Zero()</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/5e6eb715f64171fcd182039c144617fb9fdbf126/src/differentials/composite.jl#L119-L125">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.extern-Tuple{Any}" href="#ChainRulesCore.extern-Tuple{Any}"><code>ChainRulesCore.extern</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">extern(x)</code></pre><p>Makes a best effort attempt to convert a differential into a primal value. This is not always a well-defined operation. For two reasons:</p><ul><li>It may not be possible to determine the primal type for a given differential.</li></ul><p>For example, <code>Zero</code> is a valid differential for any primal.</p><ul><li>The primal type might not be a vector space, thus might not be a valid differential type.</li></ul><p>For example, if the primal type is <code>DateTime</code>, it&#39;s not a valid differential type as two  <code>DateTime</code> can not be added (fun fact: <code>Milisecond</code> is a differential for <code>DateTime</code>).</p><p>Where it is defined the operation of <code>extern</code> for a primal type <code>P</code> should be <code>extern(x) = zero(P) + x</code>.</p><p>Because of its limitations, <code>extern</code> should only really be used for testing. It can be useful, if you know what you are getting out, as it recursively removes thunks, and otherwise makes outputs more consistent with finite differencing. The more useful action in general is to call <code>+</code>, or in the case of thunks: <a href="api.html#ChainRulesCore.unthunk-Tuple{Any}"><code>unthunk</code></a>.</p><p>Note that <code>extern</code> may return an alias (not necessarily a copy) to data wrapped by <code>x</code>, such that mutating <code>extern(x)</code> might mutate <code>x</code> itself.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/5e6eb715f64171fcd182039c144617fb9fdbf126/src/differentials/abstract_differential.jl#L38-L60">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.frule-Tuple{Any,Vararg{Any,N} where N}" href="#ChainRulesCore.frule-Tuple{Any,Vararg{Any,N} where N}"><code>ChainRulesCore.frule</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">frule(f, x..., ṡelf, Δx...)</code></pre><p>Expressing <code>x</code> as the tuple <code>(x₁, x₂, ...)</code>, <code>Δx</code> as the tuple <code>(Δx₁, Δx₂, ...)</code>, and the output tuple of <code>f(x...)</code> as <code>Ω</code>, return the tuple:</p><pre><code class="language-none">(Ω, (Ω̇₁, Ω̇₂, ...))</code></pre><p>The second return value is the propagation rule, or the pushforward. It takes in differentials corresponding to the inputs (<code>ẋ₁, ẋ₂, ...</code>) and <code>ṡelf</code> the internal values of the function (for closures).</p><p>If no method matching <code>frule(f, x..., ṡelf, Δx...)</code> has been defined, then return <code>nothing</code>.</p><p>Examples:</p><p>unary input, unary output scalar function:</p><pre><code class="language-none">julia&gt; dself = Zero()
Zero()

julia&gt; x = rand();

julia&gt; sinx, sin_pushforward = frule(sin, x, dself, 1)
(0.35696518021277485, 0.9341176907197836)

julia&gt; sinx == sin(x)
true

julia&gt; sin_pushforward == cos(x)
true</code></pre><p>unary input, binary output scalar function:</p><pre><code class="language-none">julia&gt; x = rand();

julia&gt; sincosx, sincos_pushforward = frule(sincos, x, dself, 1);

julia&gt; sincosx == sincos(x)
true

julia&gt; sincos_pushforward == (cos(x), -sin(x))
true</code></pre><p>See also: <a href="api.html#ChainRulesCore.rrule-Tuple{Any,Vararg{Any,N} where N}"><code>rrule</code></a>, <a href="api.html#ChainRulesCore.@scalar_rule-Tuple{Any,Any,Vararg{Any,N} where N}"><code>@scalar_rule</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/5e6eb715f64171fcd182039c144617fb9fdbf126/src/rules.jl#L6-L57">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.rrule-Tuple{Any,Vararg{Any,N} where N}" href="#ChainRulesCore.rrule-Tuple{Any,Vararg{Any,N} where N}"><code>ChainRulesCore.rrule</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">rrule(f, x...)</code></pre><p>Expressing <code>x</code> as the tuple <code>(x₁, x₂, ...)</code> and the output tuple of <code>f(x...)</code> as <code>Ω</code>, return the tuple:</p><pre><code class="language-none">(Ω, (Ω̄₁, Ω̄₂, ...) -&gt; (s̄elf, x̄₁, x̄₂, ...))</code></pre><p>Where the second return value is the the propagation rule or pullback. It takes in differentials corresponding to the outputs (<code>x̄₁, x̄₂, ...</code>), and <code>s̄elf</code>, the internal values of the function itself (for closures)</p><p>If no method matching <code>rrule(f, xs...)</code> has been defined, then return <code>nothing</code>.</p><p>Examples:</p><p>unary input, unary output scalar function:</p><pre><code class="language-none">julia&gt; x = rand();

julia&gt; sinx, sin_pullback = rrule(sin, x);

julia&gt; sinx == sin(x)
true

julia&gt; sin_pullback(1) == (NO_FIELDS, cos(x))
true</code></pre><p>binary input, unary output scalar function:</p><pre><code class="language-none">julia&gt; x, y = rand(2);

julia&gt; hypotxy, hypot_pullback = rrule(hypot, x, y);

julia&gt; hypotxy == hypot(x, y)
true

julia&gt; hypot_pullback(1) == (NO_FIELDS, (x / hypot(x, y)), (y / hypot(x, y)))
true</code></pre><p>See also: <a href="api.html#ChainRulesCore.frule-Tuple{Any,Vararg{Any,N} where N}"><code>frule</code></a>, <a href="api.html#ChainRulesCore.@scalar_rule-Tuple{Any,Any,Vararg{Any,N} where N}"><code>@scalar_rule</code></a></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/5e6eb715f64171fcd182039c144617fb9fdbf126/src/rules.jl#L60-L105">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.unthunk-Tuple{Any}" href="#ChainRulesCore.unthunk-Tuple{Any}"><code>ChainRulesCore.unthunk</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">unthunk(x)</code></pre><p>On <code>AbstractThunk</code>s this removes 1 layer of thunking. On any other type, it is the identity operation.</p><p>In contrast to <code>extern</code> this is nonrecursive.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/5e6eb715f64171fcd182039c144617fb9fdbf126/src/differentials/thunks.jl#L86-L93">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.@scalar_rule-Tuple{Any,Any,Vararg{Any,N} where N}" href="#ChainRulesCore.@scalar_rule-Tuple{Any,Any,Vararg{Any,N} where N}"><code>ChainRulesCore.@scalar_rule</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@scalar_rule(f(x₁, x₂, ...),
             @setup(statement₁, statement₂, ...),
             (∂f₁_∂x₁, ∂f₁_∂x₂, ...),
             (∂f₂_∂x₁, ∂f₂_∂x₂, ...),
             ...)</code></pre><p>A convenience macro that generates simple scalar forward or reverse rules using the provided partial derivatives. Specifically, generates the corresponding methods for <code>frule</code> and <code>rrule</code>:</p><pre><code class="language-none">function ChainRulesCore.frule(::typeof(f), x₁::Number, x₂::Number, ...)
    Ω = f(x₁, x₂, ...)
    $(statement₁, statement₂, ...)
    return Ω, (_, Δx₁, Δx₂, ...) -&gt; (
            (∂f₁_∂x₁ * Δx₁ + ∂f₁_∂x₂ * Δx₂ + ...),
            (∂f₂_∂x₁ * Δx₁ + ∂f₂_∂x₂ * Δx₂ + ...),
            ...
        )
end

function ChainRulesCore.rrule(::typeof(f), x₁::Number, x₂::Number, ...)
    Ω = f(x₁, x₂, ...)
    $(statement₁, statement₂, ...)
    return Ω, (ΔΩ₁, ΔΩ₂, ...) -&gt; (
            NO_FIELDS,
            ∂f₁_∂x₁ * ΔΩ₁ + ∂f₂_∂x₁ * ΔΩ₂ + ...),
            ∂f₁_∂x₂ * ΔΩ₁ + ∂f₂_∂x₂ * ΔΩ₂ + ...),
            ...
        )
end</code></pre><p>If no type constraints in <code>f(x₁, x₂, ...)</code> within the call to <code>@scalar_rule</code> are provided, each parameter in the resulting <code>frule</code>/<code>rrule</code> definition is given a type constraint of <code>Number</code>. Constraints may also be explicitly be provided to override the <code>Number</code> constraint, e.g. <code>f(x₁::Complex, x₂)</code>, which will constrain <code>x₁</code> to <code>Complex</code> and <code>x₂</code> to <code>Number</code>.</p><p>At present this does not support defining for closures/functors. Thus in reverse-mode, the first returned partial, representing the derivative with respect to the function itself, is always <code>NO_FIELDS</code>. And in forward-mode, the first input to the returned propagator is always ignored.</p><p>The result of <code>f(x₁, x₂, ...)</code> is automatically bound to <code>Ω</code>. This allows the primal result to be conveniently referenced (as <code>Ω</code>) within the derivative/setup expressions.</p><p>The <code>@setup</code> argument can be elided if no setup code is need. In other words:</p><pre><code class="language-none">@scalar_rule(f(x₁, x₂, ...),
             (∂f₁_∂x₁, ∂f₁_∂x₂, ...),
             (∂f₂_∂x₁, ∂f₂_∂x₂, ...),
             ...)</code></pre><p>is equivalent to:</p><pre><code class="language-none">@scalar_rule(f(x₁, x₂, ...),
             @setup(nothing),
             (∂f₁_∂x₁, ∂f₁_∂x₂, ...),
             (∂f₂_∂x₁, ∂f₂_∂x₂, ...),
             ...)</code></pre><p>For examples, see ChainRules&#39; <code>rulesets</code> directory.</p><p>See also: <a href="api.html#ChainRulesCore.frule-Tuple{Any,Vararg{Any,N} where N}"><code>frule</code></a>, <a href="api.html#ChainRulesCore.rrule-Tuple{Any,Vararg{Any,N} where N}"><code>rrule</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/5e6eb715f64171fcd182039c144617fb9fdbf126/src/rule_definition_tools.jl#L4-L71">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.@thunk-Tuple{Any}" href="#ChainRulesCore.@thunk-Tuple{Any}"><code>ChainRulesCore.@thunk</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@thunk expr</code></pre><p>Define a <a href="api.html#ChainRulesCore.Thunk"><code>Thunk</code></a> wrapping the <code>expr</code>, to lazily defer its evaluation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/5e6eb715f64171fcd182039c144617fb9fdbf126/src/differentials/thunks.jl#L74-L78">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.AbstractDifferential" href="#ChainRulesCore.AbstractDifferential"><code>ChainRulesCore.AbstractDifferential</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>The subtypes of <code>AbstractDifferential</code> define a custom &quot;algebra&quot; for chain rule evaluation that attempts to factor various features like complex derivative support, broadcast fusion, zero-elision, etc. into nicely separated parts.</p><p>All subtypes of <code>AbstractDifferential</code> implement the following operations:</p><p><code>+(a, b)</code>: linearly combine differential <code>a</code> and differential <code>b</code></p><p><code>*(a, b)</code>: multiply the differential <code>b</code> by the scaling factor <code>a</code></p><p><code>Base.conj(x)</code>: complex conjugate of the differential <code>x</code></p><p><code>Base.zero(x) = Zero()</code>: a zero.</p><p>In general a differential type is the type of a derivative of a value. The type of the value is for contrast called the primal type. Differential types correspond to primal types, although the relation is not one-to-one. Subtypes of  <code>AbstractDifferential</code> are not the only differential types. In fact for the most common primal types, such as <code>Real</code> or <code>AbstractArray{Real}</code> the the differential type is the same as the primal type.</p><p>In a circular definition: the most important property of a differential is that it should be able to be added (by defining <code>+</code>) to another differential of the same primal type. That allows for gradients to be accumulated.</p><p>It generally also should be able to be added to a primal to give back another primal, as this facilitates gradient descent.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/5e6eb715f64171fcd182039c144617fb9fdbf126/src/differentials/abstract_differential.jl#L5-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore._normalize_scalarrules_macro_input-Tuple{Any,Any,Any}" href="#ChainRulesCore._normalize_scalarrules_macro_input-Tuple{Any,Any,Any}"><code>ChainRulesCore._normalize_scalarrules_macro_input</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">_normalize_scalarrules_macro_input(call, maybe_setup, partials)</code></pre><p>returns (in order) the correctly escaped:     - <code>call</code> with out any type constraints     - <code>setup_stmts</code>: the content of <code>@setup</code> or <code>nothing</code> if that is not provided,     -  <code>inputs</code>: with all args having the constraints removed from call, or         defaulting to <code>Number</code>     - <code>partials</code>: which are all <code>Expr{:tuple,...}</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/5e6eb715f64171fcd182039c144617fb9fdbf126/src/rule_definition_tools.jl#L96-L105">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore._zeroed_backing-Union{Tuple{Type{P}}, Tuple{P}} where P" href="#ChainRulesCore._zeroed_backing-Union{Tuple{Type{P}}, Tuple{P}} where P"><code>ChainRulesCore._zeroed_backing</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">_zeroed_backing(P)</code></pre><p>Returns a NamedTuple with same fields as <code>P</code>, and all values <code>Zero()</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/5e6eb715f64171fcd182039c144617fb9fdbf126/src/differentials/composite.jl#L141-L145">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.backing-Tuple{Tuple}" href="#ChainRulesCore.backing-Tuple{Tuple}"><code>ChainRulesCore.backing</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">backing(x)</code></pre><p>Accesses the backing field of a <code>Composite</code>, or destructures any other composite type into a <code>NamedTuple</code>. Identity function on <code>Tuple</code>. and <code>NamedTuple</code>s.</p><p>This is an internal function used to simplify operations between <code>Composite</code>s and the primal types.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/5e6eb715f64171fcd182039c144617fb9fdbf126/src/differentials/composite.jl#L82-L91">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.construct-Union{Tuple{L}, Tuple{T}, Tuple{Type{T},NamedTuple{L,T} where T&lt;:Tuple}} where L where T" href="#ChainRulesCore.construct-Union{Tuple{L}, Tuple{T}, Tuple{Type{T},NamedTuple{L,T} where T&lt;:Tuple}} where L where T"><code>ChainRulesCore.construct</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">construct(::Type{T}, fields::[NamedTuple|Tuple])</code></pre><p>Constructs an object of type <code>T</code>, with the given fields. Fields must be correct in name and type, and <code>T</code> must have a default constructor.</p><p>This internally is called to construct structs of the primal type <code>T</code>, after an operation such as the addition of a primal to a composite.</p><p>It should be overloaded, if <code>T</code> does not have a default constructor, or if <code>T</code> needs to maintain some invarients between its fields.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/5e6eb715f64171fcd182039c144617fb9fdbf126/src/differentials/composite.jl#L153-L164">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.propagation_expr-Tuple{Any,Any}" href="#ChainRulesCore.propagation_expr-Tuple{Any,Any}"><code>ChainRulesCore.propagation_expr</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">propagation_expr(Δs, ∂s)

Returns the expression for the propagation of
the input gradient `Δs` though the partials `∂s`.</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/5e6eb715f64171fcd182039c144617fb9fdbf126/src/rule_definition_tools.jl#L203-L208">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ChainRulesCore.propagator_name-Tuple{Expr,Symbol}" href="#ChainRulesCore.propagator_name-Tuple{Expr,Symbol}"><code>ChainRulesCore.propagator_name</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">propagator_name(f, propname)</code></pre><p>Determines a reasonable name for the propagator function. The name doesn&#39;t really matter too much as it is a local function to be returned by <code>frule</code> or <code>rrule</code>, but a good name make debugging easier. <code>f</code> should be some form of AST representation of the actual function, <code>propname</code> should be either <code>:pullback</code> or <code>:pushforward</code></p><p>This is able to deal with fairly complex expressions for <code>f</code>:</p><pre><code class="language-none">julia&gt; propagator_name(:bar, :pushforward)
:bar_pushforward

julia&gt; propagator_name(esc(:(Base.Random.foo)), :pullback)
:foo_pullback</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaDiff/ChainRulesCore.jl/blob/5e6eb715f64171fcd182039c144617fb9fdbf126/src/rule_definition_tools.jl#L233-L249">source</a></section><footer><hr/><a class="previous" href="writing_good_rules.html"><span class="direction">Previous</span><span class="title">Writing Good Rules</span></a></footer></article></body></html>
